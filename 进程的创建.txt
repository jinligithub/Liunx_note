进程创建
1.如何创建进程？
	* 调用frok函数。它从已存在的进程中创建一个新进程。新进程为子进程，原进程为父进程

#include<unistd.h>
pid_t fork(void);

2.当frok调用成功后，内核会做什么？
	* 分配新的内存块和内核数据给子进程
	* 将父进程的部分数据拷贝给子进程
	* 把子进程添加到系统中
	* frok返回，调度器开始调度
	* 多了PCB，虚拟地址空间，页表，映射关系

3.fork调用之后系统会发生什么变化？
	* fork之后，系统里会有两个二进制代码相同的进程。
	* frok之前父进程独立运行。fork之后的代码父子进程分别执行。
	* frok之后谁先执行由调度器决定。

4.frok的返回值
	* fork()返回值有两个。成功：父进程返回子进程的pid，子进程返回0。失败：返回-1

原因是：

5.如何理解写时拷贝？
	* 父子进程代码共享，当父子进程不再写入时，数据也是共享的。但其中一方进行写入时，以写时拷贝的形式各自私有一份。

6.写时拷贝的原因？
	* 空间：防止资源浪费。只有数据发生修改时才拷贝
	* 性能：更合理的使用空间。


7.frok的常规用法？
	* 一个父进程希望复制自己，使父子进程执行不同的代码段。（举例：父进程等待请求，子进程处理进程）
	* 一个进程要执行不同的程序，（举例：子进程在frok返回后，调用exec(程序替换函数）

8.frok调用失败的原因？
	* 资源不足：系统中有很多进程
	* 实际用户 的进程数超过了限制

9.除了frok函数可以创建子进程之外，还有哪个函数可以创建子进程？
	* vfrok函数
	* vfrok用于创建一个子进程，子进程和父进程共享地址空间（除了PCB之外，其他的虚拟地址空间，页表，以及映射关系都相同）
	* vfrok会保证子进程先运行。在子进程调用exec()函数后，父进程才可能会被调度运行


10.为什么fork有两个返回值？
	* 父子进程代码共享，数据以写时拷贝的。在fork()返回时，父子进程各自运行自己的代码段，有两个执行流，故有两个返回值。


11.父子进程为什么代码共享？
	* 代码是只读的，因为通过页表映射关系映射到的地址是代码区的，代码区是只读的（操作系统有一套保护机制保护代码，当要修改代码时页表终止进程，以防止修改代码）


12.进程运行的前提条件是？
进程的状态为R状态

13.vfork函数也是用来创建进程的但是和fork的区别是什么？
	* vfork 用于创建一个子进程，而父子进程共享地址空间（除了PCB不同其他的都一样，父子进程会在同一个地址空间内运行），fork的子进程具有独立的地址空间
	* vfork保证子进程先运行，，当他的子进程调用exec或exit之后父进程才可能被调度运行。

