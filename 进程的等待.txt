进程等待实质上为PCB的等待1.进程等待的（目的）？
	* 回收子进程资源（释放资源，避免僵尸状态），避免内存泄漏。
	* 获取子进程的退出信息。看看子进程的任务完成情况。

2.进程等待的方法？
	* wait方法:有两个或多个进程，wait等待任意一个进程退出，退出后wait会立即返回退出进程的pid
	* waitpid方法:如果子进程已经退出，调用wait、waitpid时会立即返回，并且释放资源，获取子进程的退出信息
	* 如果在任意时候调用wait，waitpid，子进程存在且正常运行，则进程可能会阻塞
	* 如果不存在该子进程，则会立即出错

waitpid的返回值？
	* 0：    等待成功，但子进程没有退出
	* >0:    等待成功
	* <0:    等待失败

2.为什么fork有两个个返回值？
	* 在fork返回时已经有两个进程了，他们在各自的逻辑空间运行,fork之后的代码共享所以他们能看到同一个id变量，又因为数据是私有的所以同一个id最后映射到不同的物理内存。所以fork可以用if分流，他们是同时执行的。

3.进程等待的方式?
	* 阻塞式：子进程没退出，父进程一直等（乘车到目的地）
	* 非阻塞方式：子进程没有退出，父进程不会一直等。会以非阻塞轮询方式访问（周期性的检测条件，会一直问子进程执行完没有）

4.父进程如何获取子进程的退出信息？
	* 通过wait或者waitpid（wait是系统调用接口）

5.如果wait有多个子进程他要怎么等待？
	* wait有多个子进程，只要任意一个子进程退出，wait就会立即返回子进程的pid。

6.挂起和唤醒?
	* 挂起：把状态设置为非R
	* 唤醒：把状态设置为R


可以通过更改进程的状态决定进程运行与否
7.退出信息包括什么
	* 退出码：a.子进程是否正常退出。b.子进程的运行结果是否正确
	* 退出信号：进程推出一般都是收到了信号

异常退出，退出码不重要

8.什么时候等待失败
	* waitpid的返回值小于0
	* 等的子进程不是你的
	* 等的子进程不存在


9.如何获取子进程的status?
	* wait和waitpid都有一个参数status。它是一个输出型参数，由操作系统填充
	* 如果传NULL，表示不关心子进程的退出状态。
	* 否则，操作系统会根据该参数，将子进程的推出信息反馈给子进程
	* status不能当作简单的整形看待，可以把它看作位图（status只研究低16位）



gdb  b:  打断点
父进程可以提取低七位的退出信号和次低八位的退出码来判断进程为何退出，以及退出结果对不对的问题

9.1如何获取退出信号？
	* 把0x7F和退出信号按位与，


9.2如何获取退出码？
	* 把退出状态右移8位和0xFF按位与




10.如何保证子进程线运行，父进程后运行？
	* 首先把进程状态设置为R，把子进程状态设置位R状态，把父进程设置为非R状态。等子进程运行完后把父进程的状态改为R



11.bash如何创建进程，如何等待进程？
	* bash通过fork创建进程，通过waitpid等待子进程


12.$?的作用是什么？
	* $？：查上一个进程退出时的退出码 ，退出码是bash放进去的，因为bash是是上一个进程的父进程


13.子进程退出时要注意什么？
	* 先看低七位有没有收到了什么信号，是否正常退出。如果异常退出，退出码就不重要了
	* 提取退出码

